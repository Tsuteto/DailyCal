// 旧暦計算拡張 based on qreki.js
// By Tsuteto

/**
 * 直前の朔・望・下弦・上弦の時刻を求める
 * 
 * @param {number} tm ユリウス日
 * @param {number} longitude 単位角（90: 朔・望・下弦・上弦）
 * @returns ユリウス日
 */
function calc_saku_lng(tm, longitude) {
	var lc,t,tm1,tm2,rm_sun,rm_moon,delta_rm,rm_moon0;
	//-----------------------------------------------------------------------
	// ループカウンタのセット
	//-----------------------------------------------------------------------
	lc = 1;
	//-----------------------------------------------------------------------
	// 時刻引数を小数部と整数部とに分解する（精度を上げるため）
	//-----------------------------------------------------------------------
	tm1 = Math.floor(tm);
	tm2 = tm - tm1 + tz;	// JST -> UTC
	//-----------------------------------------------------------------------
	// 直前の単位角の黄経差 λmoon0 を求める
	//-----------------------------------------------------------------------
    t = (tm2 + .5) / 36525 + (tm1 - 2451545) / 36525;
    rm_sun = LONGITUDE_SUN(t);
    rm_moon = LONGITUDE_MOON(t);
    delta_rm = rm_moon - rm_sun;
    rm_moon0 = longitude * Math.floor(delta_rm / longitude);
	//-----------------------------------------------------------------------
	// 繰り返し計算によって朔の時刻を計算する
	// （誤差が±1.0 sec以内になったら打ち切る。）
	//-----------------------------------------------------------------------
	var delta_t1 = 0, delta_t2 = 1;
	for( ; Math.abs( delta_t1 + delta_t2 ) > ( 1 / 86400 ) ; lc++) {
		//-------------------------------------------------------------------
		// 太陽の黄経λsun(t) ,月の黄経λmoon(t) を計算
		//	 t = (tm + .5 - 2451545) / 36525;
		//-------------------------------------------------------------------
		t = (tm2 + .5) / 36525 + (tm1 - 2451545) / 36525;
		rm_sun = LONGITUDE_SUN(t);
		rm_moon = LONGITUDE_MOON(t);
		//-------------------------------------------------------------------
		// 月と太陽の黄経差Δλ
		// Δλ＝λmoon－λsun
		//-------------------------------------------------------------------
        if (Math.abs(rm_moon0) == 180) {
            // 望を求める場合は-180か+180に寄せる
            if (rm_moon > rm_sun) {
                delta_rm = rm_moon - rm_sun - 180;
            } else {
                delta_rm = rm_moon - rm_sun + 180;
            }
        } else {
            delta_rm = rm_moon - rm_sun - rm_moon0;
        }
		//-------------------------------------------------------------------
		// ループの１回目（lc=1）で delta_rm < 0 の場合には引き込み範囲に
		// 入るように補正する
		//-------------------------------------------------------------------
		if( lc==1 && delta_rm < 0 ) {
			delta_rm = NORMALIZATION_ANGLE(delta_rm);
		}
		//-------------------------------------------------------------------
		//	 春分の近くで朔がある場合（0 ≦λsun≦ 20）で、
		//	 月の黄経λmoon≧300 の場合には、
		//	 Δλ＝ 360 － Δλ と計算して補正する
		//-------------------------------------------------------------------
		else if( rm_sun >= 0 && rm_sun <= 20 && rm_moon >= 300 ) {
			delta_rm = NORMALIZATION_ANGLE(delta_rm);
			delta_rm = 360 - delta_rm;
		}
		//-------------------------------------------------------------------
		// Δλの引き込み範囲（±40°）を逸脱した場合には、補正を行う
		//-------------------------------------------------------------------
		else if( Math.abs(delta_rm) > 40 ) {
			delta_rm = NORMALIZATION_ANGLE(delta_rm);
		}
		//-------------------------------------------------------------------
		// 時刻引数の補正値 Δt
		// delta_t = delta_rm * 29.530589 / 360;
		//-------------------------------------------------------------------
		delta_t1 = Math.floor(delta_rm * 29.530589 / 360);
		delta_t2 = delta_rm * 29.530589 / 360 - delta_t1;
		//-------------------------------------------------------------------
		// 時刻引数の補正
		// tm -= delta_t;
		//-------------------------------------------------------------------
		tm1 = tm1 - delta_t1;
		tm2 = tm2 - delta_t2;
		if( tm2 < 0 ) {
			tm1 -= 1;
			tm2 += 1;
		}
		//-------------------------------------------------------------------
		// ループ回数が15回になったら、初期値 tm を tm-26 とする。
		//-------------------------------------------------------------------
		if( lc == 15 && Math.abs(delta_t1 + delta_t2) > (1 / 86400) ) {
			tm1 = Math.floor(tm - 26);
			tm2 = 0;
		}
		//-------------------------------------------------------------------
		// 初期値を補正したにも関わらず、振動を続ける場合には初期値を答えとし
		// て返して強制的にループを抜け出して異常終了させる。
		//-------------------------------------------------------------------
		else if( lc > 30 && Math.abs(delta_t1 + delta_t2) > (1 / 86400) ) {
			tm1 = tm;
			tm2 = 0;
			break;
		}
	}
	//-----------------------------------------------------------------------
	// 戻り値の作成
	//	 時刻引数を合成し、戻り値（ユリウス日）とする
	//-----------------------------------------------------------------------
	return {jd: tm2 + tm1 - tz, rm_moon0: rm_moon0};
}
